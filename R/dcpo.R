#' Estimate Dynamic Comparative Public Opinion
#'
#' \code{dcpo} uses diverse survey data to estimate public opinion across countries and over time.
#'
#' @param df a data frame of survey items and marginals generated by \code{dcpo_setup}
#
#' @details \code{dcpo_setup}, when passed a data frame of survey items, collects the
#' responses and formats them for use with the \code{dcpo} function.
#'
#' @return a stanfit object
#'
#' @useDynLib DCPO, .registration = TRUE
#'
#' @import rstan
#' @import beepr
#' @importFrom dplyr "%>%" group_by summarize first
#'
#' @export

dcpo <- function(x,
                 seed = 324,
                 iter = 3000,
                 cores = min(4, parallel::detectCores()/2),
                 chains = 4,
                 adapt_delta = .95,
                 robust = FALSE,
                 constant_alpha = FALSE,
                 chime = TRUE) {

  rq <- x %>%
    group_by(rcode) %>%
    summarize(rq = first(qcode),
              rcp = max(cutpoint))

  dcpo_data <- list(  K    = max(x$ccode),
                      T    = max(x$tcode),
                      Q    = max(x$qcode),
                      R    = max(x$rcode),
                      N    = length(x$y_r),
                      kk   = x$ccode,
                      tt   = x$tcode,
                      kktt = x$ktcode,
                      qq   = x$qcode,
                      rr   = x$rcode,
                      rq   = rq$rq,
                      rcp  = rq$rcp,
                      y_r  = x$y_r,
                      n_r  = x$n,
                      rob  = as.numeric(robust),
                      c_a  = as.numeric(constant_alpha)
  )

  start <- proc.time()
  out1 <- stan(file = "exec/dcpo.stan",
               data = dcpo_data,
               seed = seed,
               iter = iter,
               cores = cores,
               chains = chains,
               control = list(max_treedepth = 20, adapt_delta=adapt_delta))
  runtime <- proc.time() - start
  cat("Runtime:", runtime%/%3600, "hours,", (runtime%%3600)%/%60, "minutes, and", (runtime%%3600)%%60, "seconds")

  # Chime
  if(chime) {
    beep()
  }

  return(out1)
}

#' @export
with_min_yrs <- function(x, min_yrs) {
  if (!is.na(min_yrs)) {
    x <- x %>%
      filter(year_obs >= min_yrs) %>%
      mutate(ccode = as.integer(factor(ccode)),
             tcode = as.integer(year - min(year) + 1),
             qcode = as.numeric(factor(variable, levels = unique(variable))),
             rcode = as.numeric(factor(variable_cp, levels = unique(variable_cp))),
             ktcode = (ccode-1)*max(tcode)+tcode) %>%
      arrange(ccode, tcode, qcode, rcode) %>%
      group_by(ccode) %>%
      mutate(tq = length(unique(paste(tcode, qcode))),
             year_obs = length(unique(tcode))) %>%
      ungroup()
  }
  return(x)
}
