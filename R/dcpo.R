#' Estimate Dynamic Comparative Public Opinion
#'
#' \code{dcpo} uses diverse survey data to estimate public opinion across countries and over time.
#'
#' @param x a data frame of survey items and marginals generated by \code{dcpo_setup}
#' @param scale_item a string specifying a question-cutpoint to identify the scale of the public opinion; this item will be assigned a difficulty of .5
#' @param seed an integer specifying the seed for random number generation for replication purposes
#' @param iter a positive integer specifying the number of iterations for each chain (including warmup)
#' @param chains a positive integer specifying the number of Markov chains; the default is 3
#' @param cores a positive integer specifying the number of processor cores to use; the default is the lesser of the number of chains or half the available cores
#' @param adapt_delta a double between 0 and 1; the default is .95.  Lower values complete faster at a greater risk of nonconvergence
#' @param chime play chime when complete?
#
#' @details \code{dcpo}, when passed a data frame \code{x} of survey marginals created by \code{dcpo_setup}, estimates a latent variable of public opinion.
#'
#' If a data frame of independent variables including observations for all countries that appear in \code{x} for each year in the time period from the first to last year to appear in \code{x} is passed to the argument \code{iv}, \code{dcpo} will also estimate coefficients for these predictors.
#'
#' @return a stanfit object
#'
#' @import rstan
#' @import beepr
#' @importFrom dplyr "%>%" group_by summarize first
#'
#' @export

dcpo <- function(x,
                 scale_item,
                 seed = 324,
                 iter = 3000,
                 chains = 3,
                 cores = min(chains, parallel::detectCores()/2),
                 adapt_delta = .95,
                 chime = TRUE) {

  rq <- x %>%
    group_by(rcode) %>%
    summarize(rq = first(qcode),
              rcp = max(cutpoint))

  if (!missing(scale_item)) {
    r_fixed <- x %>%
      filter(variable_cp == scale_item) %>%
      pull(rcode) %>%
      unique()
    if (length(r_fixed) > 1) {
      error("scale_item must specify a single question-cutpoint")
    }
  } else {
    r_fixed <- 0
  }


  dcpo_data <- list(  K    = max(x$ccode),
                      T    = max(x$tcode),
                      Q    = max(x$qcode),
                      R    = max(x$rcode),
                      N    = length(x$y_r),
                      kk   = x$ccode,
                      tt   = x$tcode,
                      kktt = x$ktcode,
                      qq   = x$qcode,
                      rr   = x$rcode,
                      rq   = rq$rq,
                      r_fixed = r_fixed,
                      rcp  = rq$rcp,
                      y_r  = x$y_r,
                      n_r  = x$n
  )

  dcpo_model <- stanmodels$dcpo
  out1 <- suppressWarnings(sampling(dcpo_model,
                                    data = dcpo_data,
                                    seed = seed,
                                    iter = iter,
                                    cores = cores,
                                    chains = chains,
                                    control = list(max_treedepth = 20, adapt_delta=adapt_delta)))

  # Chime
  if(chime) {
    beep()
  }

  return(out1)
}
