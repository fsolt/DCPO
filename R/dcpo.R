#' Estimate Dynamic Comparative Public Opinion
#'
#' \code{dcpo} uses diverse survey data to estimate public opinion across countries and over time.
#'
#' @param df a data frame of survey items and marginals generated by \code{dcpo_setup}
#
#' @details \code{dcpo_setup}, when passed a data frame of survey items, collects the
#' responses and formats them for use with the \code{dcpo} function.
#'
#' @return a stanfit object
#'
#' @import rstan
#' @import beepr
#' @importFrom dplyr "%>%" group_by summarize first
#'
#' @export

dcpo <- function(x,
                 seed = 324,
                 iter = 3000,
                 cores = min(4, parallel::detectCores()/2),
                 chains = 4,
                 adapt_delta = .95,
                 chime = TRUE) {

  rq <- x %>%
    group_by(rcode) %>%
    summarize(rq = first(qcode),
              rcp = max(cutpoint))

  dcpo_data <- list(  K    = max(x$ccode),
                      T    = max(x$tcode),
                      Q    = max(x$qcode),
                      R    = max(x$rcode),
                      N    = length(x$y_r),
                      kk   = x$ccode,
                      tt   = x$tcode,
                      kktt = x$ktcode,
                      qq   = x$qcode,
                      rr   = x$rcode,
                      rq   = rq$rq,
                      rcp  = rq$rcp,
                      y_r  = x$y_r,
                      n_r  = x$n
  )

  dcpo_model <- stanmodels$dcpo
  out1 <- sampling(dcpo_model,
                   data = dcpo_data,
                   seed = seed,
                   iter = iter,
                   cores = cores,
                   chains = chains,
                   control = list(max_treedepth = 20, adapt_delta=adapt_delta))

  # Chime
  if(chime) {
    beep()
  }

  return(out1)
}

#' @export
with_min_yrs <- function(x, min_yrs) {
  if (!is.na(min_yrs)) {
    x <- x %>%
      filter(year_obs >= min_yrs) %>%
      mutate(ccode = as.integer(factor(ccode)),
             tcode = as.integer(year - min(year) + 1),
             qcode = as.numeric(factor(variable, levels = unique(variable))),
             rcode = as.numeric(factor(variable_cp, levels = unique(variable_cp))),
             ktcode = (ccode-1)*max(tcode)+tcode) %>%
      arrange(ccode, tcode, qcode, rcode) %>%
      group_by(ccode) %>%
      mutate(tq = length(unique(paste(tcode, qcode))),
             year_obs = length(unique(tcode))) %>%
      ungroup()
  }
  return(x)
}
