#' Estimate Dynamic Comparative Public Opinion
#'
#' \code{dcpo} uses diverse survey data to estimate public opinion across countries and over time.
#'
#' @param x a data frame of survey items and marginals generated by \code{dcpo_setup}
#' @param seed an integer specifying the seed for random number generation for replication purposes
#' @param iter a positive integer specifying the number of iterations for each chain (including warmup)
#' @param chains a positive integer specifying the number of Markov chains; the default is 3
#' @param cores a positive integer specifying the number of processor cores to use; the default is the lesser of the number of chains or half the available cores
#' @param adapt_delta a double between 0 and 1; the default is .95.  Lower values complete faster at a greater risk of nonconvergence
#' @param iv an optional data frame of independent variables
#' @param chime play chime when complete?
#
#' @details \code{dcpo}, when passed a data frame \code{x} of survey marginals created by \code{dcpo_setup}, estimates a latent variable of public opinion.
#'
#' If a data frame of independent variables including observations for all countries that appear in \code{x} for each year in the time period from the first to last year to appear in \code{x} is passed to the argument \code{iv}, \code{dcpo} will also estimate coefficients for these predictors.
#'
#' @return a stanfit object
#'
#' @import rstan
#' @import beepr
#' @importFrom dplyr "%>%" group_by summarize first
#'
#' @export

dcpo <- function(x,
                 seed = 324,
                 iter = 3000,
                 chains = 3,
                 cores = min(chains, parallel::detectCores()/2),
                 adapt_delta = .95,
                 iv,
                 chime = TRUE) {

  rq <- x %>%
    group_by(rcode) %>%
    summarize(rq = first(qcode),
              rcp = max(cutpoint))

  if (missing(iv)) {
    dcpo_data <- list(  K    = max(x$ccode),
                        T    = max(x$tcode),
                        Q    = max(x$qcode),
                        R    = max(x$rcode),
                        N    = length(x$y_r),
                        kk   = x$ccode,
                        tt   = x$tcode,
                        kktt = x$ktcode,
                        qq   = x$qcode,
                        rr   = x$rcode,
                        rq   = rq$rq,
                        rcp  = rq$rcp,
                        y_r  = x$y_r,
                        n_r  = x$n
    )

    dcpo_model <- stanmodels$dcpo
    out1 <- suppressWarnings(sampling(dcpo_model,
                     data = dcpo_data,
                     seed = seed,
                     iter = iter,
                     cores = cores,
                     chains = chains,
                     control = list(max_treedepth = 20, adapt_delta=adapt_delta)))
  } else {
    dcpo_data <- list(  K    = max(x$ccode),
                        T    = max(x$tcode),
                        Q    = max(x$qcode),
                        R    = max(x$rcode),
                        N    = length(x$y_r),
                        kk   = x$ccode,
                        tt   = x$tcode,
                        kktt = x$ktcode,
                        qq   = x$qcode,
                        rr   = x$rcode,
                        rq   = rq$rq,
                        rcp  = rq$rcp,
                        y_r  = x$y_r,
                        n_r  = x$n,
                        V = ncol(policy),
                        W = as.matrix(policy)
    )

    dcpo_model <- stanmodels$dcpo_as_dv
    out1 <- suppressWarnings(sampling(dcpo_model,
                     data = dcpo_data,
                     seed = seed,
                     iter = iter,
                     cores = cores,
                     chains = chains,
                     control = list(max_treedepth = 20, adapt_delta=adapt_delta)))
  }

  # Chime
  if(chime) {
    beep()
  }

  return(out1)
}
