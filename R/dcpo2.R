#' Estimate Dynamic Comparative Public Opinion
#'
#' \code{dcpo} uses diverse survey data to estimate public opinion across countries and over time.
#'
#' @param df a data frame of survey items and marginals generated by \code{dcpo_setup}
#
#' @details \code{dcpo_setup}, when passed a data frame of survey items, collects the
#' responses and formats them for use with the \code{dcpo} function.
#'
#' @return a data frame
#'
#' @import rstan
#'
#' @export

library(rstan)

# data1 <- gm_a
#
# dcpo <- function(x,
#                  model_code = NULL,
#                  seed = 324,
#                  iter = 100,
#                  cores = 1,
#                  chains = 4)

### Delete these when turning into a function
seed <- 3033034
iter <- 2000
chains <- 4
cores <- chains
x <- gm_a
###

qr <- x %>% group_by(rcode) %>% summarize(qr = first(qcode),
                                          mcp = max(cutpoint))

dcpo_data <- list(  K=max(x$ccode),
                    T=max(x$tcode),
                    Q=max(x$qcode),
                    R=max(x$rcode),
                    N=length(x$y_r),
                    kk=x$ccode,
                    tt=x$tcode,
                    qq=x$qcode,
                    rr=x$rcode,
                    qr=qr$qr,
                    mcp=qr$mcp,
                    y_r=x$y_r,
                    n_r=x$n,
                    var_r = x$variance
)

dcpo_code2 <- '
  data {
    int<lower=1> K;     		// number of countries
    int<lower=1> T; 				// number of years
    int<lower=1> Q; 				// number of questions
    int<lower=1> R;         // number of question-cutpoints
    int<lower=1> N; 				// number of KTQR observations
    int<lower=1, upper=K> kk[N]; 	// country for observation n
    int<lower=1, upper=T> tt[N]; 	// year for observation n
    int<lower=1, upper=Q> qq[N];  // question for observation n
    int<lower=1, upper=R> rr[N]; 	// question-cutpoint for observation n
    int<lower=1, upper=R> qr[R];  // question for question-cutpoint r
    int<lower=1, upper=R> mcp[R]; // cutpoint for question-cutpoint r
    int<lower=0> y_r[N];    // number of respondents giving selected answer for observation n
    int<lower=0> n_r[N];    // total number of respondents for observation n
    real<lower=0> var_r[N]; 	// variance in respondents to indicator rr for observation n
  }
  transformed data {
    int G[N-1];				// number of missing years until next observed country-year (G for "gap")
    for (n in 1:N-1) {
        G[n] <- tt[n+1] - tt[n] - 1;
    }
  }
  parameters {
    real<lower=0, upper=1> alpha[K, T]; // public opinion, minus (grand) mean public opinion
    real<lower=0> gamma[R]; // discrimination of each question-cutpoint (see Stan Development Team 2015, 61; Gelman and Hill 2007, 314-320; McGann 2014, 118-120 (using 1/alpha))
    real<lower=0> sigma_gamma;  // scale of indicator discriminations (see Stan Development Team 2015, 61)
    real<lower=0, upper=.25> var_alpha[K, T]; // country-year sd in opinion (see McGann 2014, 119-120)
    real<lower=0, upper=.05> sigma_var_alpha; // scale of country-year sd in opinion
    real<lower=0, upper=1> p[N]; // final probability of random individual respondent giving selected answer for observation n (see McGann 2014, 120)
    real<lower=0, upper=1> sigma_alpha[K]; 	// country mean opinion variance parameter (see Linzer and Stanton 2012, 12)
    real<lower=0, upper=.1> sigma_alpha_var[K]; 	// country sd opinion variance parameter
    real<lower=0> b[R];  // "the degree of stochastic variation between question administrations" (McGann 2014, 122)
    real<lower=0, upper=1> tau[R]; // shift in difficulty across each cutpoint of each question
    real<lower=0> sigma_tau;   // scale of cutpoint difficulties (see Stan Development Team 2015, 61)
  }
  transformed parameters {
    real<lower=0, upper=1> beta[R]; // position ("difficulty") of question-cutpoint r (see Stan Development Team 2015, 61; Gelman and Hill 2007, 314-320; McGann 2014, 118-120 (using lambda))
    real<lower=0, upper=1> m[N]; // expected probability of random individual giving selected answer
    beta <- tau;
    for (r in 2:R) {
      if (qr[r]==qr[r-1])
      beta[r] <- beta[r-1] + (tau[r] * (1 - beta[r - 1]));
    }

    for (n in 1:N) {
      m[n] <- inv_logit(sqrt(gamma[rr[n]]^2+var_alpha[kk[n], tt[n]]) * (alpha[kk[n], tt[n]] - beta[rr[n]]));
    }
  }
  model {
    sigma_gamma ~ cauchy(0, 2);
    sigma_tau ~ cauchy(0, .25);
    sigma_var_alpha ~ cauchy(0, .01);
    b ~ cauchy(0, 5);

    gamma ~ lognormal(0, sigma_gamma);
    tau ~ normal(0, sigma_tau);

    // actual number of respondents giving selected answer
    y_r ~ binomial(n_r, p);

    for (n in 1:N) {
      // individual probability of selected answer
      p[n] ~ beta(b[rr[n]]*m[n]/(1 - m[n]), b[rr[n]]);

      var_alpha[kk[n], tt[n]] ~ normal(var_r[n], sigma_var_alpha);
      // prior for alpha and var_alpha for the next observed year by country as well as for all intervening missing years
      if (n < N) {
        if (tt[n] < T) {
          for (g in 0:G[n]) {
            alpha[kk[n], tt[n]+g+1] ~ normal(alpha[kk[n], tt[n]+g], sigma_alpha[kk[n]]);
            var_alpha[kk[n], tt[n]+g+1] ~ normal(var_alpha[kk[n], tt[n]+g], sigma_alpha_var[kk[n]]);
          }
        }
      }
    }
  }
'

start <- proc.time()
out1 <- stan(model_code = dcpo_code2,
             data = dcpo_data,
             seed = seed,
             iter = 60,
             cores = cores,
             chains = chains,
             control = list(max_treedepth = 20,
                            adapt_delta = .8))
runtime <- proc.time() - start
runtime

lapply(get_sampler_params(out1, inc_warmup = FALSE),
       summary, digits = 2)

#Chime
beep()
